//
// src/order/drivers/tests/test05.cc -- sloan on a finite element mesh
//
// $Id: test05.cc,v 1.2 2000/02/18 01:32:09 kumfert Exp $
//
//  Gary Kumfert, Old Dominion University
//  Copyright(c) 1997-1998, Old Dominion University.  All rights reserved.
// 
//  Permission to use, copy, modify, distribute and sell this software and
//  its documentation for any purpose is hereby granted without fee, 
//  provided that the above copyright notice appear in all copies and
//  that both that copyright notice and this permission notice appear
//  in supporting documentation.  Old Dominion University makes no
//  representations about the suitability of this software for any 
//  purpose.  It is provided "as is" without express or implied warranty.
//
///////////////////////////////////////////////////////////////////////
//
//

#include <iostream.h>
#include "spindle/Graph.h"
#include "spindle/SloanEngine.h"
#include "spindle/CompressionMap.h"
#include "spindle/GraphCompressor.h"
#include "spindle/MapUtils.h"
#include "samples/fe_mesh.h"

#ifdef HAVE_NAMESPACES
using namespace SPINDLE_NAMESPACE;
#endif

int main() {
  ios::sync_with_stdio();

  /////////////////////
  //
  // create fine graph
  //

  Graph graph( nvtxs, (const int*)Aptr, (const int*)Aind );
  graph.validate();
  if ( ! graph.isValid() ) {
    cerr << "Error: Cannot create valid graph." << endl;
    exit( -1 );
  }
  
  /////////////////////////////////
  //
  // create a Sloan ordering object on the compressed graph
  //
  SloanEngine ordering( &graph );
 
  // set any options here

  ordering.execute();

  ///////////////////////////////////////
  //
  // report how well the compression went.
  //
  int cNVtxs =  ordering.getGraphCompressor()->queryCompressedNVtxs();
  cout << "Compressed graph from " << nvtxs << " vertices to "
       << cNVtxs << endl;

  ////////////////////////////////
  //
  // Now show some stuff about the compression.
  // (this whole block is optional)
  //
  {
    const PermutationMap *cperm = ordering.getCoarsePermutation();
    if ( !cperm || !cperm->isValid() ) { 
      cerr << "Error: could not confirm a valid compressed permutation." << endl;
      exit( -1 );
    }
    const int* cnew2old = cperm->getNew2Old().lend();
    {for (int i=0; i<cNVtxs; i++) {
      cout << "cPerm[" << i << "] = " << cnew2old[i] << endl;
    }}
    cperm->dump( stdout );
    cout << endl;
    const int * fine2coarse = ordering.getGraphCompressor()->getFine2Coarse()->lend();
    cout << "CompressionMap:" ;
    for( int i=0; i<nvtxs; ++i ) { 
      cout << fine2coarse[i] << " ";
    }
    cout << endl;
  }

  ////////////////////////////////
  //
  // create a PermutationMap class based on the ordering
  // generated by the Sloan class
  //
  const PermutationMap * perm = ordering.getPermutation();

  if ( ! perm->isValid() ) {
    cerr << "Error: could not confirm a valid compressed permutation." << endl;
    exit( -1 );
  }

  // print out the uncompressed permutation
  const int* new2old  = perm->getNew2Old().lend();
  {for (int i=0; i<nvtxs; i++) {
    cout << "perm[" << i << "] = " << new2old[i] << endl;
  }}

  //  delete perm; not needed, since its still owned by the ordering
}

/*
 * NOTE: Below is how it was done before the commonality
 *       between RCMEngine, SloanEngine, and MinPriorityEngine
 *       was combined into a single parent class OrderingAlgorithm.
 *       Note how the compression was handled explicitly before.
 *
 * 
main() {
  ios::sync_with_stdio();

  /////////////////////
  //
  // create fine graph
  //

  Graph fineGraph( nvtxs, (const int*)Aptr, (const int*)Aind );
  fineGraph.validate();
  if ( ! fineGraph.isValid() ) {
    cerr << "Error: Cannot create valid graph." << endl;
    exit( -1 );
  }
  
  /////////////////
  //
  // do graph compression
  //
  GraphCompressor compressor;
  compressor.setGraph( &fineGraph );
  if ( !compressor.execute() ) {
    cerr << "Error: graph compression failed." << endl;
    exit( -1 );
  }

  ///////////////////////////////////////
  //
  // report how well the compression went.
  //
  int cNVtxs =  compressor.queryCompressedNVtxs();
  cout << "Compressed graph from " << nvtxs << " vertices to "
       << cNVtxs << endl;


  ////////////////
  //
  // create a formal CompressionMap class
  //  (we'll need it later)
  //
  CompressionMap cMap( nvtxs, cNVtxs );
  cMap.getFine2Coarse().take( *(compressor.getFine2Coarse())  );
  cMap.validate();
  if ( ! cMap.isValid() ) {
    cerr << "Error: could not confirm a valid compressing mapping." << endl;
    exit( -1 );
  }
  

  /////////////////////////////////
  //
  // now instantiate the compressed graph
  //
  Graph* coarseGraph;
  if ( (coarseGraph = compressor.createCompressedGraph()) == 0 ) {
    cerr << "Error: could not create valid compressed graph." << endl;
    exit(-1);
  }

  /////////////////////////////////
  //
  // create a Sloan ordering object on the compressed graph
  //
  SloanEngine ordering( coarseGraph );
 
  // set any options here

  ordering.execute();

  ////////////////////////////////
  //
  // create a PermutationMap class based on the ordering
  // generated by the Sloan class
  //
  PermutationMap cPerm( cNVtxs );
  cPerm.getNew2Old().take( ordering.getNew2Old() );
  cPerm.validate();
  if ( ! cPerm.isValid() ) {
    cerr << "Error: could not confirm a valid compressed permutation." << endl;
    exit( -1 );
  }
  // print the permutation on the compressed graph
  //                        /---------hack to force const version of getNew2Old()
  const int* cNew2Old  = ((const PermutationMap &)cPerm).getNew2Old().lend();
  {for (int i=0; i<cNVtxs; i++) {
    cout << "cPerm[" << i << "] = " << cNew2Old[i] << endl;
  }}

  ///////////////////////////////////
  //
  // Now create an uncompressed permutation.
  // To do so, we need the CompressionMap and the PermutationMap
  //
  cPerm.dump( stdout );
  cout << endl;
  cMap.dump( stdout );
  cout << endl;
  PermutationMap * perm = MapUtils::createUncompressedPermutationMap( &cPerm, &cMap );
  if (( perm == 0 ) || (!perm->isValid() )) { 
    cerr << "Error: could not create valid uncompressed permutation" << endl;
    exit( -1 );
  }
  // print out the uncompressed permutation
  const int* New2Old  = perm->getNew2Old().lend();
  {for (int i=0; i<nvtxs; i++) {
    cout << "perm[" << i << "] = " << New2Old[i] << endl;
  }}

  delete coarseGraph;
  delete perm;
}
 */
